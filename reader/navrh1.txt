Nevýhoda nasledujúceho riešenia je, že switch sa vykoná toľko krát, koľko je
symbolou vo vstupe.

int main()
{
	state = INITIAL_STATE;
	name_buffer = ...;

	while (s = next_sym())
	{
		switch (state)
		{
			case TAG_NAME_STATE:
				if (is_space(s))
					tag_name = neme_buffer
					state = ATTRIBS_STATE
				else id (s == '>')
					state = TEXT_STATE
				else					
					name_buffer += s;
				break;

			...			
		}
	}
}



s = ... // current symbol

main()
{
	next_sym()

	while (s)
	{
		if (s != '<')
			continue;
		else
			read_element()

		next_sym()
	}
}


read_element()
	read_element_name()
	if (is_alpha(a))
		read_element_attribs()
	

read_element_name()
	buf = ''
	next_sym()
	while (is_alphanum(s))
		buf += s
		next_sym()


read_element_attribs()
	while (s != '>')
		read_element_attrib()


read_element_attrib()
	read_key()
	read_value()


read_key()
	buf = ''
	while (is_alphanum(s))
		buf += s
		next_sym()


read_value()
	buf = ''
	next_sym()  // s='\"'
	next_sym()
	while (s != '\"')  // <- treba vziať do úvahu escape-ovane znaky
		buf += s
		next_sym()

